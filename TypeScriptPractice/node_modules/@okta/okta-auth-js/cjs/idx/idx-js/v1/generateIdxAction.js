"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

exports.default = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _client = require("../client");

var _actionParser = require("./actionParser");

var _makeIdxState = require("./makeIdxState");

/*!
 * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */

/* eslint-disable max-len */
// @ts-nocheck
const generateDirectFetch = function generateDirectFetch({
  actionDefinition,
  defaultParamsForAction = {},
  immutableParamsForAction = {},
  toPersist
}) {
  const target = actionDefinition.href;
  return async function (params) {
    const headers = {
      'content-type': 'application/json',
      'accept': actionDefinition.accepts || 'application/ion+json'
    };
    const body = (0, _stringify.default)({ ...defaultParamsForAction,
      ...params,
      ...immutableParamsForAction
    });
    const credentials = toPersist && toPersist.withCredentials === false ? 'omit' : 'include';
    return (0, _client.request)(target, {
      method: actionDefinition.method,
      headers,
      body,
      credentials
    }).then(response => {
      const respJson = response.json();

      if (response.ok) {
        return respJson;
      } else if (response.status === 401 && response.headers.get('WWW-Authenticate') === 'Oktadevicejwt realm="Okta Device"') {
        // Okta server responds 401 status code with WWW-Authenticate header and new remediation
        // so that the iOS/MacOS credential SSO extension (Okta Verify) can intercept
        // the response reaches here when Okta Verify is not installed
        // we need to return an idx object so that
        // the SIW can proceed to the next step without showing error
        return respJson.then(err => {
          let ms = (0, _makeIdxState.makeIdxState)(err, toPersist); // set to true if flow should be continued without showing any errors

          ms.stepUp = true;
          return _promise.default.reject(ms);
        });
      }

      return respJson.then(err => {
        return _promise.default.reject((0, _makeIdxState.makeIdxState)(err, toPersist));
      });
    }).then(idxResponse => (0, _makeIdxState.makeIdxState)(idxResponse, toPersist));
  };
}; // TODO: Resolve in M2: Either build the final polling solution or remove this code
// const generatePollingFetch = function generatePollingFetch( { actionDefinition, defaultParamsForAction = {}, immutableParamsForAction = {} } ) {
//   // TODO: Discussions ongoing about when/how to terminate polling: OKTA-246581
//   const target = actionDefinition.href;
//   return async function(params) {
//     return fetch(target, {
//       method: actionDefinition.method,
//       headers: {
//         'content-type': actionDefinition.accepts,
//       },
//       body: JSON.stringify({ ...defaultParamsForAction, ...params, ...immutableParamsForAction })
//     })
//       .then( response => response.ok ? response.json() : response.json().then( err => Promise.reject(err)) )
//       .then( idxResponse => makeIdxState(idxResponse) );
//   };
// };


const generateIdxAction = function generateIdxAction(actionDefinition, toPersist) {
  // TODO: leaving this here to see where the polling is EXPECTED to drop into the code, but removing any accidental trigger of incomplete code
  // const generator =  actionDefinition.refresh ? generatePollingFetch : generateDirectFetch;
  const generator = generateDirectFetch;
  const {
    defaultParams,
    neededParams,
    immutableParams
  } = (0, _actionParser.divideActionParamsByMutability)(actionDefinition);
  const action = generator({
    actionDefinition,
    defaultParamsForAction: defaultParams[actionDefinition.name],
    immutableParamsForAction: immutableParams[actionDefinition.name],
    toPersist
  });
  action.neededParams = neededParams;
  return action;
};

var _default = generateIdxAction;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=generateIdxAction.js.map