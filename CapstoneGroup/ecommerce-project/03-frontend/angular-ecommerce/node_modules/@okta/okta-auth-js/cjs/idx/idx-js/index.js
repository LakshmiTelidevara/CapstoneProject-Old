"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

exports.default = void 0;

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _url = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/url"));

var _introspect = _interopRequireDefault(require("./introspect"));

var _interact = _interopRequireDefault(require("./interact"));

var _parsers = _interopRequireDefault(require("./parsers"));

var _client = require("./client");

var _util = require("./util");

/*!
 * Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 */

/* eslint-disable complexity, max-statements, max-len, camelcase */
// @ts-nocheck
const LATEST_SUPPORTED_IDX_API_VERSION = '1.0.0';

const start = async function start({
  withCredentials,
  clientId,
  domain,
  issuer,
  stateHandle,
  interactionHandle,
  version,
  redirectUri,
  state,
  scopes,
  codeChallenge,
  codeChallengeMethod,
  activationToken,
  recoveryToken
}) {
  var _issuer, _issuer2;

  issuer = (_issuer = issuer) === null || _issuer === void 0 ? void 0 : _issuer.replace(/\/+$/, '');
  const baseUrl = ((_issuer2 = issuer) === null || _issuer2 === void 0 ? void 0 : (0, _indexOf.default)(_issuer2).call(_issuer2, '/oauth2')) > 0 ? issuer : issuer + '/oauth2'; // org AS uses domain as AS, but we need the base url for calls

  const toPersist = {
    baseUrl,
    clientId,
    state,
    withCredentials
  };

  if (!domain && !issuer) {
    return _promise.default.reject({
      error: 'issuer is required'
    });
  }

  if (!stateHandle && !clientId) {
    // redirectUri is only required on self-hosted flow
    return _promise.default.reject({
      error: 'clientId is required'
    });
  }

  if (!stateHandle && !redirectUri) {
    // redirectUri is only required on self-hosted flow
    return _promise.default.reject({
      error: 'redirectUri is required'
    });
  }

  if (!stateHandle && !(codeChallenge && codeChallengeMethod)) {
    return _promise.default.reject({
      error: 'PKCE params (codeChallenge, codeChallengeMethod) are required'
    });
  }

  if (!domain) {
    domain = new _url.default(issuer).origin;
  }

  (0, _util.validateVersionConfig)(version);

  if (!stateHandle && !interactionHandle) {
    // start a new transaction
    try {
      const interactParams = {
        withCredentials,
        clientId,
        baseUrl,
        scopes,
        redirectUri,
        codeChallenge,
        codeChallengeMethod,
        state,
        activationToken,
        recoveryToken
      };
      const interaction_handle = await (0, _interact.default)(interactParams);
      interactionHandle = interaction_handle;
      toPersist.interactionHandle = interactionHandle;
    } catch (error) {
      return _promise.default.reject({
        error
      });
    }
  }

  try {
    const {
      makeIdxState
    } = (0, _parsers.default)(version);
    const idxResponse = await (0, _introspect.default)({
      withCredentials,
      domain,
      interactionHandle,
      stateHandle,
      version
    }).catch(err => _promise.default.reject({
      error: 'introspect call failed',
      // Transform all errors into an IdX State object.
      // This allows IdX based errors (messages) to optionally proceed with remediation forms
      details: makeIdxState(err, toPersist)
    }));
    const idxState = makeIdxState(idxResponse, toPersist);
    return idxState;
  } catch (error) {
    return _promise.default.reject({
      error
    });
  }
};

const {
  makeIdxState
} = (0, _parsers.default)(LATEST_SUPPORTED_IDX_API_VERSION);
var _default = {
  start,
  introspect: _introspect.default,
  interact: _interact.default,
  makeIdxState,
  client: _client.HttpClient,
  LATEST_SUPPORTED_IDX_API_VERSION
};
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=index.js.map